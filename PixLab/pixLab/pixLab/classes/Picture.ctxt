#BlueJ class context
comment0.target=Picture
comment0.text=\r\n\ A\ class\ that\ represents\ a\ picture.\ \ This\ class\ inherits\ from\ \r\n\ SimplePicture\ and\ allows\ the\ student\ to\ add\ functionality\ to\r\n\ the\ Picture\ class.\ \ \r\n\ \r\n\ @author\ Barbara\ Ericson\ ericson@cc.gatech.edu,\ Peter\ Olson\ mrpeterfolson@gmail.com\r\n
comment1.params=
comment1.target=Picture()
comment1.text=\r\n\ Constructor\ that\ takes\ no\ arguments\ \r\n
comment10.params=pixelIslandLimit\ includeDiagonals
comment10.target=void\ clearIslands(int,\ boolean)
comment10.text=@@For\ B/W\ Pictures\:@@
comment11.params=pixelIslandLimit\ includeDiagonals\ origColor\ newColor
comment11.target=void\ clearIslands(int,\ boolean,\ java.awt.Color,\ java.awt.Color)
comment11.text=\r\n\ @@For\ B/W\ Pictures\:@@\r\n\ \r\n\ Method\ that\ removes\ islands\ of\ black\ pixels\ whose\ total\ pixel\ count\r\n\ is\ less\ than\ the\ parameter\ 'pixelIslandLimit'\r\n\ @param\ pixelIslandLimit\ Any\ islands\ of\ black\ pixels\ whose\ total\ count\ is\ less\ than\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ this\ limit\ will\ be\ converted\ to\ Color.WHITE\ pixels\r\n\ @param\ includeDiagonals\ True\ if\ diagonals\ are\ included\ in\ islands,\ false\ otherwise\r\n\ @param\ origColor\ The\ original\ color\ of\ the\ pixel\r\n\ @param\ newColor\ The\ new\ color\ of\ the\ pixel\r\n
comment12.params=thisPixel\ island\ pixels\ imageNeighbors\ includeDiagonals\ pixelIslandLimit\ origColor
comment12.target=java.util.ArrayList\ getIsland(Picture.Neighbor,\ java.util.ArrayList,\ Pixel[][],\ Picture.Neighbor[][],\ boolean,\ int,\ java.awt.Color)
comment12.text=\r\n\ Method\ to\ find\ all\ of\ the\ neighbors\ of\ a\ black\ pixel.\ The\ parameter\ 'includeDiagonals'\r\n\ controls\ whether\ diagonal\ neighbors\ should\ be\ included\ or\ not\r\n\ \r\n\ This\ method\ works\ by\ finding\ a\ path\ of\ Color.WHITE\ pixels\ that\ goes\ around\ the\ island\r\n\ containing\ the\ pixel.\ Then,\ every\ black\ pixel\ within\ the\ perimeter\ is\ added\ to\ the\ list\ and\r\n\ then\ returned\r\n\ \r\n\ Note\:\ This\ method\ returns\ null\ if\ the\ island\ is\ greater\ than\ the\ pixelIslandLimit.\ If\ this\r\n\ \ \ \ \ \ \ limit\ +\ 2\ rows\ are\ found\ that\ have\ black\ pixels,\ null\ is\ returned\ right\ away,\ saving\r\n\ \ \ \ \ \ \ processing\ time\ (and\ making\ this\ method\ actually\ usable)\r\n\ \r\n\ @param\ thisPixel\ The\ neighbor\ being\ observed\r\n\ @param\ island\ The\ list\ of\ neighbors\ that\ make\ up\ this\ island\r\n\ @param\ pixels\ The\ pixels\ of\ the\ picture\r\n\ @param\ imageNeighbors\ The\ entire\ picture\ of\ Neighbor\ objects,\ which\ keep\ track\ of\ whether\ each\ has\ been\ visited\ or\ not\r\n\ @param\ includeDiagonals\ True\ if\ diagonal\ black\ pixels\ should\ be\ included\ as\ neighbors,\ false\ otherwise\r\n\ @param\ pixelIslandLimit\ The\ limit\ to\ the\ size\ of\ an\ island.\ Note\ that\ this\ method\ returns\ null\ if\ any\ number\ of\ rows\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ are\ found\ greater\ than\ this\ limit\ plus\ two\r\n\ @param\ origColor\ The\ original\ color\ of\ the\ pixel.\ These\ pixels\ make\ up\ the\ island\r\n\ @return\ ArrayList<Neighbor>\ The\ list\ of\ Neighbors\ that\ belong\ to\ this\ island,\ or\ null\ if\ the\ island\ size\ must\ be\ greater\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ than\ the\ pixelIslandLimit\r\n
comment13.params=dir\ pix\ pixels
comment13.target=boolean\ hasDir(Picture.Direction,\ Pixel,\ Pixel[][])
comment13.text=\r\n\ Method\ that\ tests\ whether\ the\ current\ pixel\ is\ on\ the\ top\ row\ or\ not\r\n\ @param\ dir\ The\ current\ direction\ of\ iteration\r\n\ @param\ pix\ The\ pixel\ to\ check\r\n\ @param\ pixels\ The\ image\ of\ pixels\r\n\ @return\ boolean\ True\ if\ this\ direction\ can\ be\ iterated,\ false\ otherwise\r\n
comment14.params=a\ b\ includeDiagonals
comment14.target=boolean\ isNextTo(Picture.Neighbor,\ Picture.Neighbor,\ boolean)
comment14.text=\r\n\ Method\ that\ gets\ whether\ two\ pixels\ are\ neighbors\ or\ not.\r\n\ @param\ a\ First\ pixel\r\n\ @param\ b\ Second\ pixel\r\n\ @param\ includeDiagonals\ True\ if\ diagonals\ are\ considered\ neighbors,\ false\ otherwise\r\n\ @return\ boolean\ True\ if\ they\ are\ neighbors,\ false\ otherwise\r\n
comment15.params=xOffset\ yOffset\ thisPixel\ pixels\ origColor
comment15.target=boolean\ getNeighbor(int,\ int,\ Pixel,\ Pixel[][],\ java.awt.Color)
comment15.text=\r\n\ Method\ that\ gets\ whether\ this\ pixel\ has\ a\ black\ neighbor\ in\ their\ upper-left\ diagonal\r\n\ \r\n\ @@NOTE\:\ If\ you\ use\ 'thisPixel'\ and\ are\ use\ subsections,\ 'thisPixel'\ will\ still\ contain\r\n\ \ \ \ \ \ \ \ \ the\ original\ coordinates\ from\ the\ larger\ Picture\!\ You\ should\ instead\ use\ the\r\n\ \ \ \ \ \ \ \ \ other\ getNeighbor(...)\ function\ that\ uses\ fixed\ row\ and\ col\ coordinates\r\n\ \r\n\ @param\ xOffset\ The\ x\ offset\ from\ this\ pixel's\ location\r\n\ @param\ yOffset\ The\ y\ offset\ from\ this\ pixel's\ location\r\n\ @param\ pix\ The\ pixel\ to\ check\r\n\ @param\ pixels\ The\ image\ of\ pixels\r\n\ @param\ origColor\ The\ color\ a\ pixel\ has\ that\ belongs\ to\ an\ island\r\n\ @return\ boolean\ True\ if\ this\ neighbor\ exists,\ false\ otherwise\r\n
comment16.params=xOffset\ yOffset\ row\ col\ pixels\ origColor
comment16.target=boolean\ getNeighbor(int,\ int,\ int,\ int,\ Pixel[][],\ java.awt.Color)
comment16.text=\r\n\ Method\ that\ gets\ whether\ this\ pixel\ has\ a\ black\ neighbor\ in\ their\ upper-left\ diagonal\r\n\ \r\n\ @@NOTE\:\ This\ method\ is\ ONLY\ for\ looking\ at\ subsections\ of\ a\ larger\ image,\ where\ the\ Pixel\r\n\ \ \ \ \ \ \ \ \ data\ does\ NOT\ match\ the\ subsection\ coordinates\!\ See\ example\ in\ the\ linearize(...)\r\n\ \ \ \ \ \ \ \ \ method,\ where\ subsections\ are\ pathed,\ and\ thus\ each\ subsection\ has\ different\r\n\ \ \ \ \ \ \ \ \ coordinates\ that\ the\ larger\ Picture\r\n\ \r\n\ @param\ xOffset\ The\ x\ offset\ from\ this\ pixel's\ location\r\n\ @param\ yOffset\ The\ y\ offset\ from\ this\ pixel's\ location\r\n\ @param\ row\ The\ row\ of\ the\ Pixel\r\n\ @param\ col\ The\ col\ of\ the\ Pixel\r\n\ @param\ pixels\ The\ image\ of\ pixels\r\n\ @param\ origColor\ The\ color\ a\ pixel\ has\ that\ belongs\ to\ an\ island\r\n\ @return\ boolean\ True\ if\ this\ neighbor\ exists,\ false\ otherwise\r\n
comment17.params=thisPixel\ island\ pixels\ imageNeighbors\ includeDiagonals
comment17.target=java.util.ArrayList\ getIslandRecursive(Picture.Neighbor,\ java.util.ArrayList,\ Pixel[][],\ Picture.Neighbor[][],\ boolean)
comment17.text=\r\n\ @@NOTE\:\ This\ method\ uses\ recursion.\ Any\ medium\ to\ large\ images\ (100x100px\ or\ greater)\r\n\ \ \ \ \ \ \ \ \ will\ likely\ result\ in\ a\ StackOverflow.\ It\ is\ not\ recommended\ that\ you\ use\ this\r\n\ \ \ \ \ \ \ \ \ method,\ except\ for\ educational\ purposes\ (it\ does\ work\ though)\r\n\ \r\n\ Method\ to\ find\ all\ of\ the\ neighbors\ of\ a\ black\ pixel.\ The\ parameter\ 'includeDiagonals'\r\n\ controls\ whether\ diagonal\ neighbors\ should\ be\ included\ or\ not\r\n\ \r\n\ This\ method\ works\ by\ recursively\ finding\ all\ neighbors\ of\ a\ black\ pixel,\ then\ finding\ all\ neighbors\r\n\ of\ each\ neighbor,\ etc.\ Once\ a\ pixel\ has\ no\ more\ non-visited\ black\ pixel\ neighbors,\ the\ method\ is\ returned,\r\n\ and\ the\ stack\ resumes\ from\ that\ last\ method\ call\r\n\ \r\n\ @param\ thisPixel\ The\ neighbor\ being\ observed\r\n\ @param\ island\ The\ list\ of\ neighbors\ that\ make\ up\ this\ island\r\n\ @param\ pixels\ The\ pixels\ of\ the\ picture\r\n\ @param\ imageNeighbors\ The\ entire\ picture\ of\ Neighbor\ objects,\ which\ keep\ track\ of\ whether\ each\ has\ been\ visited\ or\ not\r\n\ @param\ includeDiagonals\ True\ if\ diagonal\ black\ pixels\ should\ be\ included\ as\ neighbors,\ false\ otherwise\r\n\ @return\ ArrayList<Neighbor>\ The\ list\ of\ Neighbors\ that\ belong\ to\ this\ island\r\n
comment18.params=islandNeighbors\ imageNeighbors\ pixels\ newColor
comment18.target=void\ removeIsland(java.util.ArrayList,\ Picture.Neighbor[][],\ Pixel[][],\ java.awt.Color)
comment18.text=\r\n\ Method\ to\ remove\ all\ of\ the\ neighbors\ in\ the\ list\ by\ changing\ their\ colors\ to\ Color.WHITE\r\n\ @param\ islandNeighbors\ The\ neighbor\ pixels\ that\ compose\ the\ island\ of\ black\ pixels\r\n\ @param\ imageNeighbors\ The\ entire\ picture\ of\ Neighbor\ objects,\ which\ keep\ track\ of\ whether\ each\ has\ been\ visited\ or\ not\r\n\ @param\ pixels\ The\ pixels\ of\ the\ picture\r\n\ @param\ newColor\ The\ new\ color\ of\ the\ island\ pixel\ that\ is\ removed\r\n
comment19.params=fromPic\ startRow\ startCol
comment19.target=void\ copy(Picture,\ int,\ int)
comment19.text=\r\n\ Method\ to\ copy\ pixels\ from\ the\ given\ Picture\r\n\ to\ this\ Picture\ at\ the\ location\ specified\r\n\ @param\ fromPic\ the\ picture\ to\ copy\ from\r\n\ @param\ startRow\ the\ start\ row\ to\ copy\ to\r\n\ @param\ startCol\ the\ start\ col\ to\ copy\ to\r\n
comment2.params=fileName
comment2.target=Picture(java.lang.String)
comment2.text=\r\n\ Constructor\ that\ takes\ a\ file\ name\ and\ creates\ the\ picture\ \r\n\ @param\ fileName\ the\ name\ of\ the\ file\ to\ create\ the\ picture\ from\r\n
comment20.params=fromPixels\ startRow\ startCol
comment20.target=void\ copy(Pixel[][],\ int,\ int)
comment20.text=\r\n\ Method\ to\ copy\ pixels\ from\ a\ 2D\ array\ of\ Pixels\ to\ the\ current\ Picture\r\n\ @param\ pixels\ The\ pixels\ to\ copy\r\n\ @param\ startRow\ The\ row\ to\ start\ copying\ at\ within\ this\ picture\r\n\ @param\ startcol\ The\ col\ to\ start\ copying\ at\ within\ this\ picture\r\n
comment21.params=toPicture\ startRow\ startCol
comment21.target=void\ copyTo(Picture,\ int,\ int)
comment21.text=\r\n\ Method\ to\ copy\ pixels\ from\ this\ Picture\ to\ another\r\n\ \r\n\ This\ method\ will\ copy\ pixels\ from\ this\ Picture\ starting\ from\r\n\ the\ startingRow\ and\ startingCol\ position,\ and\ go\ until\ the\r\n\ new\ Picture\ is\ filled\ or\ until\ the\ bounds\ of\ this\ Picture\ is\r\n\ reached\r\n
comment22.params=pixels\ toPicture
comment22.target=void\ copyTo(Pixel[][],\ Picture)
comment22.text=\r\n\ Method\ to\ copy\ pixels\ from\ this\ Picture\ to\ another\r\n\ \r\n\ This\ method\ works\ best\ when\ pixels\ and\ toPicture\ are\ the\r\n\ same\ dimensions.\ It\ also\ works\ if\ toPicture\ is\ larger\ than\r\n\ pixels\r\n\ @param\ toPicture\ The\ picture\ to\ copy\ to\r\n
comment23.params=
comment23.target=void\ createCollage()
comment23.text=Method\ to\ create\ a\ collage\ of\ several\ pictures
comment24.params=sectionWidth
comment24.target=void\ defuzz(int)
comment24.text=@@For\ B/W\ pictures\:@@
comment25.params=sectionWidth\ neighbors
comment25.target=void\ defuzz(int,\ int)
comment26.params=sectionWidth\ offsetX\ offsetY\ neighbors
comment26.target=void\ defuzz(int,\ int,\ int,\ int)
comment26.text=\r\n\ @@For\ B/W\ pictures\:@@\r\n\ \r\n\ Method\ to\ remove\ 'fuzz'\ from\ pixels.\ Fuzz\ is\ defined\ as\ any\r\n\ black\ squares\ that\ have\ x\ or\ less\ neighbors,\ where\ x\ is\ the\ parameter\ neighbors\r\n\ @param\ sectionWidth\ The\ width\ of\ the\ section\ being\ defuzzed\r\n\ @param\ offsetX\ The\ starting\ offset\ in\ the\ x\ direction\r\n\ @param\ offsetY\ The\ starting\ offset\ in\ the\ y\ direction\r\n\ @param\ neighbors\ Pixels\ with\ this\ many\ or\ less\ neighbors\ that\ are\ Color.BLACK\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ will\ be\ changed\ to\ be\ Color.WHITE\r\n
comment27.params=sectionWidth
comment27.target=void\ superDefuzz(int)
comment27.text=@@For\ B/W\ Pictures\:@@
comment28.params=sectionWidth\ neighbors
comment28.target=void\ superDefuzz(int,\ int)
comment28.text=\r\n\ @@For\ B/W\ Pictures\:@@\r\n\ \r\n\ Method\ that\ calls\ the\ defuzz\ three\ different\ times,\r\n\ in\ order\ to\ cover\ all\ edge\ all\ edges\ of\ scope\ passes\r\n\ @param\ sectionWidth\ The\ width\ of\ the\ section\ being\ defuzzed\r\n\ @param\ neighbors\ Pixels\ with\ this\ many\ or\ less\ neighbors\ that\ are\ Color.BLACK\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ will\ be\ changed\ to\ be\ Color.WHITE\r\n
comment29.params=x\ y\ pixels\ origColor
comment29.target=int\ totalNeighbors(int,\ int,\ Pixel[][],\ java.awt.Color)
comment29.text=\r\n\ @@For\ B/W\ Pictures\:@@\r\n\ \r\n\ Method\ that\ determines\ the\ total\ neighbors\ of\ a\ pixel\r\n\ @param\ x\ The\ x\ coordinate\ of\ the\ pixel\r\n\ @param\ y\ The\ y\ coordinate\ of\ the\ pixel\r\n\ @param\ pixels\ The\ 2D\ array\ of\ pixels\ of\ the\ picture\r\n\ @param\ origColor\ The\ color\ of\ the\ neighbors\r\n\ @return\ int\ The\ total\ neighbors\ of\ this\ pixel\r\n
comment3.params=height\ width
comment3.target=Picture(int,\ int)
comment3.text=\r\n\ Constructor\ that\ takes\ the\ width\ and\ height\r\n\ @param\ height\ the\ height\ of\ the\ desired\ picture\r\n\ @param\ width\ the\ width\ of\ the\ desired\ picture\r\n
comment30.params=pixelList
comment30.target=void\ drawPixels(java.util.ArrayList)
comment30.text=Method\ to\ draw\ a\ list\ of\ pixels\ on\ this\ image
comment31.params=pixelList\ lineThickness
comment31.target=void\ drawPixels(java.util.ArrayList,\ int)
comment31.text=Method\ to\ draw\ a\ list\ of\ pixels\ on\ this\ image
comment32.params=section\ pixelList
comment32.target=void\ drawPixels(Pixel[][],\ java.util.ArrayList)
comment32.text=Method\ to\ draw\ a\ list\ of\ pixels\ on\ a\ section\ of\ an\ image
comment33.params=section\ pixelList\ lineThickness
comment33.target=void\ drawPixels(Pixel[][],\ java.util.ArrayList,\ int)
comment33.text=\r\n\ Method\ to\ draw\ a\ list\ of\ pixels\ on\ a\ section\ of\ an\ image\r\n\ @param\ section\ The\ section\ to\ draw\ the\ pixels\ to\r\n\ @param\ pixelList\ The\ list\ of\ pixels\ to\ draw\r\n\ @param\ lineThickness\ The\ thickness\ of\ the\ line\ \r\n
comment34.params=path
comment34.target=boolean\ isHorizontalPath(java.util.ArrayList)
comment34.text=\r\n\ Method\ that\ determines\ which\ direction\ the\ path\ is\ moving\r\n\ @param\ path\ The\ path\ of\ pixels\r\n\ @return\ boolean\ True\ if\ the\ path\ is\ horizontal,\ false\ otherwise\r\n
comment35.params=edgeDist
comment35.target=void\ edgeDetection(int)
comment35.text=\r\n\ Method\ to\ show\ large\ changes\ in\ color\ \r\n\ @param\ edgeDist\ the\ distance\ for\ finding\ edges\r\n
comment36.params=pixelIslandLimit\ includeDiagonals
comment36.target=void\ fillIslands(int,\ boolean)
comment36.text=@@For\ B/W\ Pictures\ only\:@@
comment37.params=pixelIslandLimit\ includeDiagonals\ origColor\ newColor
comment37.target=void\ fillIslands(int,\ boolean,\ java.awt.Color,\ java.awt.Color)
comment37.text=\r\n\ @@For\ B/W\ Pictures\ only\:@@\r\n\ \r\n\ Method\ that\ fills\ all\ gaps\ of\ the\ specified\ color\ with\ a\ different\ color\r\n\ \r\n\ Note\:\ This\ is\ the\ same\ as\ clearingIslands\ of\ a\ given\ size,\ but\ with\ the\ colors\ switched\r\n\ \r\n\ @param\ pixelIslandLimit\ Islands\ that\ have\ this\ limit\ or\ less\ are\ changed\ to\ 'newColor'\r\n\ @param\ includeDiagonals\ If\ true,\ counts\ diagonal\ pixels\ as\ belonging\ to\ the\ given\ gap\r\n\ @param\ origColor\ The\ color\ of\ the\ gaps\r\n\ @param\ newColor\ The\ color\ to\ change\ the\ gaps\ to\r\n
comment38.params=
comment38.target=void\ filterRed()
comment38.text=\r\n\ Method\ to\ bring\ out\ the\ red\ colors\ and\ reduce\ the\ green\ and\ blue\ colors\r\n
comment39.params=
comment39.target=void\ filterGreen()
comment39.text=\r\n\ Method\ to\ bring\ out\ the\ green\ colors\ and\ reduce\ the\ red\ and\ blue\ colors\r\n
comment4.params=copyPicture
comment4.target=Picture(Picture)
comment4.text=\r\n\ Constructor\ that\ takes\ a\ picture\ and\ creates\ a\ \r\n\ copy\ of\ that\ picture\r\n\ @param\ copyPicture\ the\ picture\ to\ copy\r\n
comment40.params=
comment40.target=void\ filterBlue()
comment40.text=\r\n\ Method\ to\ bring\ out\ the\ blue\ colors\ and\ reduce\ the\ red\ and\ green\ colors\r\n
comment41.params=second
comment41.target=void\ findDifferences(Picture)
comment41.text=\r\n\ @@For\ B/W\ pictures\:@@\r\n\ \r\n\ Method\ that\ compares\ two\ pictures\ and\ saves\ an\ image\ of\ their\ differences\r\n\ @param\ second\ The\ second\ pic\r\n
comment42.params=strength
comment42.target=void\ gaussianBlur(Picture.Blur)
comment42.text=\r\n\ Method\ that\ applies\ a\ Gaussian\ blur\ effect\ to\ the\ image.\r\n\ The\ effect\ can\ apply\ mild,\ medium,\ or\ strong\ blur\ effects.\r\n\ @param\ strength\ The\ strength\ of\ the\ blur.\ Either\ Blur.MILD,\ Blur.MEDIUM,\ or\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Blur.STRONG\r\n
comment43.params=
comment43.target=void\ grayscale()
comment43.text=\r\n\ Method\ that\ grayscales\ an\ image\r\n
comment44.params=lineThickness
comment44.target=void\ linearize(int)
comment44.text=\r\n\ @@For\ B/W\ Pictures\:@@\r\n\ \r\n\ Method\ that\ converts\ sections\ of\ pixels\ into\ their\ linear\ direction.\r\n\ \r\n\ It\ is\ recommended\ that\ you\ use\ the\ following\ methods\ on\ your\ B/W\ image\r\n\ before\ running\ this\ function,\ in\ the\ following\ order\:\r\n\ \ \ \ 1)\ edgeDetection(...)\r\n\ \ \ \ 2)\ superDefuzz(...)\r\n\ \ \ \ 3)\ clearIslands(...)\r\n\ \ \ \ 4)\ fillIslands(...)\r\n\ \r\n\ After\ this\ method,\ it\ is\ recommended\ that\ you\ run\ the\ followings\ method(s)\:\r\n\ \ \ \ 1)\ thin(...)\ (I\ haven't\ written\ this\ yet.\ It\ would\ remove\ all\ black\ sections\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (if\ they\ exist--see\ setPath\ method)\ and\ then\ connect\ existing\ paths\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\ one\ another,\ the\ goal\ of\ being\ that\ the\ end\ result\ would\ resemble\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ a\ better\ edge\ detection\ image\ than\ just\ running\ edgeDetection\ alone\r\n\ @param\ lineThickness\ The\ thickness\ of\ the\ lines,\ in\ pixels\r\n
comment45.params=
comment45.target=void\ testSetPath()
comment45.text=\r\n\ @@For\ B/W\ pictures\:@@\r\n\ \r\n\ Method\ to\ test\ whether\ a\ small\ picture\ (the\ size\ of\ a\ section)\ works\ correctly\r\n\ using\ the\ setPath(...)\ method\r\n
comment46.params=path\ pixels
comment46.target=void\ printPath(java.util.ArrayList,\ Pixel[][])
comment46.text=\r\n\ Method\ used\ to\ print\ a\ path\ of\ Neighbors\r\n\ @param\ path\ The\ path\ of\ neighbor\ objects\r\n\ @param\ pixels\ The\ pixel\ array\ of\ this\ picture\r\n
comment47.params=pixels\ startingRow\ startingCol\ numRows\ numCols
comment47.target=Pixel[][]\ subarray(Pixel[][],\ int,\ int,\ int,\ int)
comment47.text=\r\n\ Method\ to\ get\ a\ smaller\ 2D\ array\ from\ a\ 2D\ array\r\n
comment48.params=section\ lineThickness
comment48.target=void\ setPath(Pixel[][],\ int)
comment48.text=\r\n\ @@For\ B/W\ Pictures\:@@\r\n\ \r\n\ Method\ that\ sets\ the\ path\ within\ a\ given\ sector.\r\n\ This\ method\ will\ also\ expand\ the\ width\ of\ the\ path\ by\ the\ value\r\n\ 'lineThickness'.\ For\ details\ on\ the\ algorithm,\ see\ 'getPath(...)'\r\n\ \r\n\ @param\ section\ The\ 2D\ array\ of\ pixels\r\n\ @param\ lineThickness\ The\ path\ thickness\ to\ be\ set\r\n
comment49.params=section
comment49.target=java.util.ArrayList\ getPath(Pixel[][])
comment49.text=\r\n\ @@For\ B/W\ Pictures\:@@\r\n\ \r\n\ Method\ that\ returns\ a\ path\ of\ neighbors\ within\ a\ given\ sector.\r\n\ This\ method\ tries\ to\ cross\ the\ width\ of\ the\ section\ over\ one\ nested\ loop,\ and\ the\ height\r\n\ for\ the\ next.\ If\ there\ exists\ a\ path,\ note\ the\ center-most,\ smallest-ycoord\ black\ neighbors\ as\r\n\ a\ path,\ or\ the\ center-most,\ smallest-xcoord\ black\ neighbors\ as\ a\ path.\r\n\ \r\n\ Directionality\ is\ determined\ by\ the\ longest\ path,\ but\ a\ section\ having\ all\ four\r\n\ edges\ pathed\ returns\ null,\ as\ does\ having\ no\ paths.\ Otherwise,\ there\ can\ be\ a\r\n\ horizontal\ path,\ vertical\ path,\ or\ any\ of\ the\ four\ possible\ diagonal\ paths\ that\r\n\ exist\ between\ adjacent\ edges.\ A\ path\ must\ have\ a\ greater\ distance\ than\r\n\ MIN_PATH_LENGTH\ in\ order\ to\ be\ considered\ a\ path\ (paths\ can't\ simply\ clip\r\n\ corners,\ otherwise\ they\ are\ considered\ not\ a\ path.\ Other\ sections\ should\r\n\ pick\ up\ this\ path,\ so\ scrub\ this\ section\ of\ paths).\r\n\ \r\n\ Examples\:\r\n\ \r\n\ \ \ \ Starting\ Section\ \ \ \ \ \ \ \ After\ method\ call\ (for\ setter,\ line\ width\ 1)\r\n\ \r\n\ \ \ \ oXXXo\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ oooXo\r\n\ \ \ \ XXXoX\ \ \ \ \ \ \ \ \ \ \ --->\ \ \ \ XXXoX\ \ \ \ \ \ \ \ \ \ \ Horizontal\ Path\ found\r\n\ \ \ \ XXXXX\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ooooo\r\n\ \ \ \ ooooo\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ooooo\r\n\ \ \ \ ooooo\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ooooo\r\n\ \ \ \ \r\n\ \ \ \ \r\n\ \ \ \ XXXXo\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ooXoo\r\n\ \ \ \ oooXo\ \ \ \ \ \ \ \ \ \ \ --->\ \ \ \ oooXo\ \ \ \ \ \ \ \ \ \ \ Vertical\ Path\ found\r\n\ \ \ \ oXXXo\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ooXoo\r\n\ \ \ \ XXXoo\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ oXooo\r\n\ \ \ \ ooXoo\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ooXoo\r\n\ \ \ \ \r\n\ \ \ \ \r\n\ \ \ \ ooooo\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ooooo\r\n\ \ \ \ ooooo\ \ \ \ \ \ \ \ \ \ \ --->\ \ \ \ ooooo\ \ \ \ \ \ \ \ \ \ \ Diagonal\ (Down,\ Right)\ Path\ found\r\n\ \ \ \ oooXX\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ooooX\ \ \ \ \ \ \ \ \ \ \ Valid\ path\ since\ length\ >\ (MIN_PATH_LENGTH\ \=\ 3)\r\n\ \ \ \ ooXXX\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ooXXo\r\n\ \ \ \ oXXXo\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ oXooo\r\n\ \ \ \ \r\n\ \ \ \ \r\n\ \ \ \ oXXXo\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ oXXoo\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ XXXXX\r\n\ \ \ \ XXoXo\ \ \ \ \ \ \ \ \ \ \ --->\ \ \ \ XooXo\ \ \ \ \ \ \ \ \ \ \ --->\ \ \ \ XXXXX\ \ \ \ \ \ Horizontal\ and\ Vertical\ path\ found.\r\n\ \ \ \ XooXX\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ oooXX\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ XXXXX\ \ \ \ \ \ Null\ is\ returned;\ Section\ set\ to\ all\ black\r\n\ \ \ \ XXooX\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ooooX\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ XXXXX\r\n\ \ \ \ oooXo\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ oooXo\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ XXXXX\r\n\ \ \ \ \r\n\ \ \ \ \r\n\ \ \ \ oooXX\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ooooo\r\n\ \ \ \ ooXoo\ \ \ \ \ \ \ \ \ \ \ --->\ \ \ \ ooooo\ \ \ \ \ \ \ \ \ \ \ No\ horizontal,\ vertical,\ or\ diagonal\ paths\ found\r\n\ \ \ \ ooooX\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ooooo\ \ \ \ \ \ \ \ \ \ \ Empty\ list\ returned;\ Section\ set\ to\ all\ white\r\n\ \ \ \ XXooX\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ooooo\r\n\ \ \ \ oXXoo\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ooooo\r\n\ \r\n\ @@NOTE\:\ This\ algorithm\ does\ not\ work\ for\ particular\ scenarios.\ Any\ section\ that\ is\ 'zigzaggy'\ has\ a\ change\r\n\ \ \ \ \ \ \ \ \ of\ failing.\ For\ instance,\ the\ following\ example\ will\ not\ find\ a\ valid\ path,\ despite\ there\ being\ one\:\r\n\ \ \ \ \r\n\ \ \ \ ooooXoo\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ooooooo\r\n\ \ \ \ oooXooo\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ooooooo\ \ \ \ \ \ \ \ \ No\ matter\ whether\ the\ left,\ middle,\ or\ right\ directions\ are\r\n\ \ \ \ ooXXooo\ \ \ \ \ \ \ \ \ --->\ \ \ \ ooooooo\ \ \ \ \ \ \ \ \ prioritized,\ the\ algorithm\ will\ regardless\ get\ 'stuck'\ on\r\n\ \ \ \ ooXoXoo\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ooooooo\ \ \ \ \ \ \ \ \ either\ nub-like\ branch\ on\ the\ left\ and\ right\ of\ the\ main\r\n\ \ \ \ ooooXXo\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ooooooo\ \ \ \ \ \ \ \ \ path.\ Thus,\ the\ current\ algorithm\ can't\ be\ foolproof,\ unless\r\n\ \ \ \ oooXoXo\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ooooooo\ \ \ \ \ \ \ \ \ a\ recursive\ type\ search\ is\ taken,\ such\ as\ 'Djikstra's'\ algo\ type\r\n\ \ \ \ ooXoooo\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ooooooo\ \ \ \ \ \ \ \ \ solution.\ However,\ with\ such\ large\ amounts\ of\ data\ to\ process,\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ a\ stack\ overflow\ error\ is\ almost\ certain\r\n\ \r\n\ @param\ section\ The\ 2D\ array\ of\ pixels\r\n\ @return\ ArrayList<Neighbor>\ The\ path\ of\ Neighbors\ that\ connect\ from\ one\ edge\ of\ the\ section\ to\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ another.\ Returns\ null\ if\ there\ is\ no\ path,\ or\ there\ are\ \r\n
comment5.params=image
comment5.target=Picture(java.awt.image.BufferedImage)
comment5.text=\r\n\ Constructor\ that\ takes\ a\ buffered\ image\r\n\ @param\ image\ the\ buffered\ image\ to\ use\r\n
comment50.params=section\ horizontalPath\ FIRST\ SECOND\ THIRD
comment50.target=int\ getHorizontalPath(Pixel[][],\ java.util.ArrayList,\ int,\ int,\ int)
comment50.text=\r\n\ @@For\ B/W\ only\:@@\r\n\ \r\n\ Method\ that\ gets\ the\ horizontal\ path\ of\ a\ section\r\n\ @param\ section\ The\ section\ of\ the\ Picture\ (composed\ of\ Pixels\ in\ a\ 2D\ array)\r\n\ @param\ horizontalPath\ The\ list\ of\ Neighbors\ in\ this\ horizontal\ path\r\n\ @param\ FIRST\ This\ determines\ which\ direction\ the\ path\ checks\ for\ first\ (either\ UP-RIGHT\ neighbor\ (-1),\ MIDDLE-RIGHT\ neighbor\ (0),\ or\ DOWN_RIGHT\ neighbor\ (1))\r\n\ @param\ SECOND\ Which\ checks\ for\ second\r\n\ @param\ THIRD\ Which\ checks\ for\ third\r\n\ @return\ int\ 0\ -->\ There\ is\ a\ horizontal\ path\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ 1\ -->\ There\ is\ a\ diagonal\ horizontal\ path\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ 2\ -->\ There\ are\ no\ horizontal\ or\ diagonal\ paths\r\n
comment51.params=section\ verticalPath\ FIRST\ SECOND\ THIRD
comment51.target=int\ getVerticalPath(Pixel[][],\ java.util.ArrayList,\ int,\ int,\ int)
comment51.text=\r\n\ @@For\ B/W\ only\:@@\r\n\ \r\n\ Method\ that\ gets\ the\ vertical\ path\ of\ a\ section\r\n\ @param\ section\ The\ section\ of\ the\ Picture\ (composed\ of\ Pixels\ in\ a\ 2D\ array)\r\n\ @param\ verticalPath\ The\ list\ of\ Neighbors\ in\ this\ vertical\ path\r\n\ @param\ FIRST\ This\ determines\ which\ direction\ the\ path\ checks\ for\ first\ (either\ DOWN-LEFT\ neighbor\ (-1),\ DOWN-MIDDLE\ neighbor\ (0),\ or\ DOWN_RIGHT\ neighbor\ (1))\r\n\ @param\ SECOND\ Which\ checks\ for\ second\r\n\ @param\ THIRD\ Which\ checks\ for\ third\r\n\ @return\ int\ 0\ -->\ There\ is\ a\ vertical\ path\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ 1\ -->\ There\ is\ a\ diagonal\ vertical\ path\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ 2\ -->\ There\ are\ no\ vertical\ or\ diagonal\ paths\r\n
comment52.params=
comment52.target=void\ makeOpaque()
comment52.text=\r\n\ Method\ that\ makes\ an\ image\ completely\ opaque\r\n
comment53.params=
comment53.target=void\ minimizeColors()
comment53.text=\r\n\ Method\ that\ reduces\ color\ scheme\ to\ just\ Color.RED,\ Color.ORANGE,\ Color.YELLOW,\r\n\ Color.GREEN,\ Color.CYAN,\ Color.BLUE,\ DARK_BLUE\=(0,0,139),\ Color.MAGENTA,\r\n\ PURPLE\=(128,0,128),\ Color.PINK,\ BROWN\=(102,51,0),\ Color.LIGHT_GRAY,\r\n\ Color.GRAY,\ Color.DARK_GRAY,\ Color.BLACK,\ and\ Color.WHITE\r\n
comment54.params=
comment54.target=void\ mirrorHorizontal()
comment54.text=\ Method\ that\ mirrors\ the\ picture\ around\ a\ \r\n\ horizontal\ mirror\ in\ the\ center\ of\ the\ picture\r\nfrom\ left\ to\ right
comment55.params=
comment55.target=void\ mirrorTemple()
comment55.text=Mirror\ just\ part\ of\ a\ picture\ of\ a\ temple
comment56.params=
comment56.target=void\ mirrorVertical()
comment56.text=\ Method\ that\ mirrors\ the\ picture\ around\ a\ \r\n\ vertical\ mirror\ in\ the\ center\ of\ the\ picture\r\nfrom\ left\ to\ right
comment57.params=startingRow\ startingCol\ width\ height
comment57.target=void\ subPicture(int,\ int,\ int,\ int)
comment57.text=\r\n\ Method\ to\ take\ a\ piece\ of\ a\ Picture\ to\ create\ a\ new\ Picture\r\n\ @param\ startingRow\ The\ top\ left\ x\ coordinate\ of\ the\ new\ Picture\r\n\ @param\ startingCol\ The\ top\ left\ y\ coordinate\ of\ the\ new\ Picture\r\n\ @param\ width\ The\ width\ of\ the\ new\ Picture\r\n\ @param\ height\ The\ height\ of\ the\ new\ Picture\r\n
comment58.params=
comment58.target=void\ toBW()
comment58.text=\r\n\ Method\ to\ convert\ a\ picture\ to\ Color.BLACK\ and\ Color.WHITE\ pixels\ only\r\n
comment59.params=
comment59.target=void\ zeroRed()
comment59.text=Method\ to\ set\ the\ red\ to\ 0
comment6.params=
comment6.target=java.lang.String\ toString()
comment6.text=\r\n\ Method\ to\ return\ a\ string\ with\ information\ about\ this\ picture.\r\n\ @return\ a\ string\ with\ information\ about\ the\ picture\ such\ as\ fileName,\r\n\ height\ and\ width.\r\n
comment60.params=
comment60.target=void\ zeroGreen()
comment60.text=Method\ to\ set\ the\ green\ to\ 0
comment61.params=
comment61.target=void\ zeroBlue()
comment61.text=Method\ to\ set\ the\ blue\ to\ 0
comment62.params=args
comment62.target=void\ main(java.lang.String[])
comment62.text=\ Main\ method\ for\ testing\ -\ each\ class\ in\ Java\ can\ have\ a\ main\ \r\n\ method\r\n\ \r\n\ Image\ names\ in\ folder\ --\r\n\ \ \ \ \ \ arch.jpg\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ jenny-red.jpg\ \ \ \ \ \ \ swan.jpg\r\n\ \ \ \ \ \ barbaraS.jpg\ \ \ \ \ \ \ \ \ \ \ \ KatieFancy.jpg\ \ \ \ \ \ temple.jpg\r\n\ \ \ \ \ \ beach.jpg\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ kitten2.jpg\ \ \ \ \ \ \ \ \ thruDoor.jpg\r\n\ \ \ \ \ \ blue-mark.jpg\ \ \ \ \ \ \ \ \ \ \ koala.jpg\ \ \ \ \ \ \ \ \ \ \ wall.jpg\r\n\ \ \ \ \ \ blueMotorcycle.jpg\ \ \ \ \ \ moon-surface.jpg\ \ \ \ water.jpg\r\n\ \ \ \ \ \ butterfly.jpg\ \ \ \ \ \ \ \ \ \ \ ***\ nike.png\ ***\ \ \ \ whiteFlower.jpg\r\n\ \ \ \ \ \ caterpillar.jpg\ \ \ \ \ \ \ \ \ rainbow.jpg\ \ \ \ \ \ \ \ \ rainbowCoat.jpg\r\n\ \ \ \ \ \ CumberlandIsland.jpg\ \ \ \ redMotorcycle.jpg\ \ \ msg.jpg\r\n\ \ \ \ \ \ femaleLionAndHall.jpg\ \ \ robot.jpg\r\n\ \ \ \ \ \ flower1.jpg\ \ \ \ \ \ \ \ \ \ \ \ \ seagull.jpg\r\n\ \ \ \ \ \ flower2.jpg\ \ \ \ \ \ \ \ \ \ \ \ \ snowman.jpg\r\n
comment7.params=interval\ color
comment7.target=void\ addGrid(int,\ java.awt.Color)
comment7.text=\r\n\ Method\ to\ add\ a\ grid\ to\ the\ image\r\n\ @param\ interval\ Grid\ line\ separation,\ in\ pixels\r\n\ @param\ color\ The\ color\ of\ the\ lines\r\n
comment8.params=color
comment8.target=void\ allToColor(java.awt.Color)
comment8.text=Method\ that\ paints\ this\ Picture\ to\ be\ all\ one\ color
comment9.params=section\ color
comment9.target=void\ allToColor(Pixel[][],\ java.awt.Color)
comment9.text=\r\n\ Method\ that\ paints\ the\ pixel\ section\ to\ be\ all\ one\ color\r\n\ @param\ color\ The\ color\ to\ paint\ this\ Picture\r\n
numComments=63
